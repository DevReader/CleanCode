# 더보기
## 생산자-소비자, 읽기-쓰기, 식사하는 철학자들 해결 알고리즘
### 생산자-소비자 
- 버퍼를 동기화시켜 정상적으로 동작하게 함
- 이 때 뮤텍스(Mutex)나 세마포어(Semaphore)를 사용해 문제를 해결
> **뮤텍스(Mutex)** 란? <br/>
한 프로세스나 한 스레드에서만 소유될 수 있는 Key 를 기반으로 한 상호배제 기법으로, 이 객체를 소유한 스레드/프로세스만 공유자원에 접근 가능하게 함.

> **세마포어(Semaphore)** 란? <br/>
사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성하는 기법으로, 공유 자원에 접근할 수 있는 프로세스의 최대 허용치만큼 사용자 동시 접근 가능.

- 두 방법 다 데이터 무결성을 보장할 수 없음
- 모든 교착상태 해결 불가

### 읽기-쓰기
신호등처럼, Reader들이 모두 끝날 때까지 기다리지 말고 일정 시간까지만 Reader가 읽은 후에 읽기

### 식사하는 철학자들 해결 알고리즘
- 한 쪽씩 잡지 말고, 양 쪽을 다 잡은 후 포크를 잡을 권리를 넘기는 방식(ex.양쪽을 동시에 잡기, 왼쪽을 잡았다면 오른쪽 포크를 잡기 전까지 사용권 넘기지 않기 등)
- 타임아웃을 도입해서, 사용권이 넘어갔다면 쥐고 있는 포크 반납하기
- 포크에 고유 값을 부여해 고유값이 높은/낮은 순으로 포크를 잡게 하기


<br/>
<br/>

# 정리
## 동시성이 필요한 이유?
>동시성은 결합(coupliing)을 없애는 전략으로 무엇(what)과 언제(when)를 분리한다.
- 무엇과 언제를 분리하면시스템을 이해하기 쉽고, 문제를 분리하기 쉽기 떄문에 애플리케이션 구조와 효율이 극적으로 나아짐
- 단일 스레드로 커버되지 않는 응답 시간과 작업 처리량을 다중 스레드를 사용해 개선할 수 있음

### 미신과 오해
- 동시성은 항상 성능을 높여준다 ❌<br/>
대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아짐
- 동시성을 구현해도 설계는 변하지 않는다 ❌<br/>
단일 스레드 시스템과 다중 스레드 시스템은 설계가 다름. 무엇과 언제를 분리하면 시스템 구조 크게 바뀜
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다 ❌<br/>
컨테이너의 동작 방식, 동시 수정, 데드락 등의 문제를 어떻게 피할 수 있는지를 알아야 함

<br/>

- 동시성은 다소 부하를 유발한다 ✅
- 동시성은 복잡하다 ✅
- 일반적으로 동시성 버그는 재현하기 어렵다 ✅
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다 ✅


## 난관
동시성을 구현하기 어려운 이유에는 무수히 많은 경로 중 **일부** 경로가 잘못된 경로를 내놓을 수 있다는 것이 있음


## 동시성 방어 원칙
### 단일 책임 원칙(Single Responsibility Principle, SRP)
> SRP란? 
<br/> 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙
- 동시성은 그 복잡성 때문에 따로 분리해야 함
- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있음
- 동시성 코드에는 독자적인 난관이 있고 그 난관은 다른 코드에서 겪는 난관과 다르며 훨씬 어려움
- 잘못 구현한 동시성 코드는 별의별 방법으로 실패함

➡️ 동시성 코드는 다른 코드와 분리하라

### 따름 정리(corollary) 자료 범위를 제한하라
- 공유 자료를 수정하면서 스레드가 서로 간섭하는 현상이 발생할 수 있음
- 코드 내 임계 영역(ciritical section)을 synchronized 키워드로 보호하길 권장

➡️ 자료를 캡슐화(encapsulation)하라. 공유 자료를 최대한 줄여라.

### 따름 정리: 자료 사본을 사용하라
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋음
- 객체를 복사해 읽기 전용으로 사용
- 객체를 복사하는 시간과 부하가 걱정될 수 있으나 사본을 통해 동기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 큼

### 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 모든 정보를 비공유 출처에서 가져와 로컬변수에 저장함으로써 다른 스레드와 자료를 공유하지 않고 클라이언트 요청 하나를 처리함
- 다른 스레드와 동기화할 필요가 없어짐

➡️ 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라


## 라이브러리를 이해하라
### 스레드 환경에 안전한 콜렉션
➡️ 언어가 제공하는 클래스를 검토하라. 자바에서는 ```java.util.concurrent```, ```java.util.concurrent.atomic```,```java.util.concurrent.locks``` 를 익혀라

## 실행 모델을 이해하라
>용어 정리<br/>
```한정된 자원(Bound Resource)``` 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예다.
```상호 배제(Mutual Exclusion)``` 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
```기아(Starvation)``` 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. 예를 들어, 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이어질 경우, 긴 스레드가 기아 상태에 빠진다.
```데드락(Deadlock)``` 여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.
```라이브락(Livelock)``` 락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.

### 생산자-소비자(Produce-Consumer)
- 한정된 자원을 사용하는 생산자와 소비자의 경우 둘 다 진행 가능한 시점에서 동시에 서로의 시그널을 기다리는 경우가 발생할 수 있음(ex.대기열이 비어있을 때 정보를 생성해 대기열에 삽입하는 생성자 스레드 & 대기열에 정보가 있을 때 정보를 가져오는 소비자 스레드)

### 읽기-쓰기(Readers-Writers)
- 주로 읽기 스레드를 위해 공유자원을 사용하지만 이따금 쓰기 스레드가 공유자원을 갱신하는 구조일 때, 처리율(throughput)이 문제의 핵심임
- 처리율을 강조할 경우 기아(starvation)현상이 나타나거나 오래된 정보가 쌓임
- 갱신을 허용하면 읽기 스레드와 쓰기 스레드에서 복잡한 균형잡기가 필요해지므로 한쪽이 다른 한쪽을 기다리느라 처리율이 떨어짐
- 가장 간단한 전략은 한쪽 스레드가 다른 한쪽 스레드가 없을 때까지 버퍼를 기다리는 방식이지만 다른 한쪽 스레드가 계속해서 이어지면 기다리는 스레드는 기아 상태애 빠지게 됨

### 식사하는 철학자들(Dining Philosophers)
- 철학자들은 둥근 식탁 위에 앉아 있고 각 철학자들 왼쪽에는 포크가, 둥근 식탁 중앙에는 스파게티가 있음. 이 상황에서 철학자들은 배가 고파지면 양 손에 포크를 쥐고 스파게티를 먹을 수 있는데, 양 쪽의 철학자 중 한 명이 포크를 사용중이라면 양손에 포크를 쥘 수 없으므로 포크를 내려두는 걸 기다려야 함.
- 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하 등이 일어날 수 있음

➡️ 위에서 설명한 기본 알고리즘과 각 해법을 이해하라

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 동기화 하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려움 버그가 생길 수 있음
- 공유 클래스 하나에 동기화된 메서드가 여럿이라면 구현이 올바른지 다시 한 번 확인

➡️ 공유 객체 하나에는 메서드 하나만 사용하라

### 만약 공유 객체 하나에 여러 메서드가 필요한 상황이 생겼다면
- 클라이언트에서 잠금<br/>
클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠그고 마지막 메서드를 호출할 때까지 잠금 유지
- 서버에서 잠금<br/>
서버에, 서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현. 클라이언트는 이 메서드 호출
- 연결(Adapted 서버)<br/>
잠금을 수행하는 중간 단계 수행. 서버에서 잠금과 유사하지만 원래 서버는 변경되지 않음.


## 동기화하는 부분을 작게 만들어라
- 락은 스레드를 지연시키고 부하를 가중시키므로 synchronized 문을 남발하는 코드는 바람직하지 않음
- 임계 영역은 반드시 보호해야 하고, 최대한 줄여야 함. 다만 필요 이상으로 임계영역 크기를 키우면 스레드 간 경쟁이 늘고 프로그램 성능이 떨어짐

➡️ 동기화하는 부분을 최대한 작게 만들어라

## 올바른 종료 코드는 구현하기 어렵다
올바르지 못한 종료 코드를 가질 경우 데드락 문제가 가장 흔하게 발생됨

➡️ 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라. 생각보다 오래 걸린다. 생각보다 어려우므로 이미 나온 알고리즘을 검토하라

## 스레드 코드 테스트하기
코드가 올바르다고 증명하기는 현실적으로 불가능하지만 충분한 테스트는 위험을 낮춤

➡️ 문제를 노출하는 테스트 케이스를 작성하라. 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라. 테스트가 실패하면 원인을 추적하라. 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대로 안 된다.



### 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
다중 스레드 코드는 때떄로 말이 안되는 오류를 발생시키고, 매우 드물게 나타나 재현이 어려움

➡️ 시스템 실패를 '일회성'이라 치부하지 마라

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인하라

➡️ 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라. 먼저 스레드 환경 밖에서 코드를 돌려라

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라
- 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔봄
- 스레드 코드를 실제 환경이나 테스트 환경에서 돌려봄
- 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려봄
- 반복 테스트가 가능하도록 테스트 케이스 작성

➡️ 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라

### 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라
- 적절한 스레드 개수를 파악하려면 상당한 시행착오가 필요
- 다양한 설정으로 프로그램의 성능 측정 방법 강구
- 스레드 개수 조율하기 쉽게 코드 구현
- 프로그램이 돌아가는 도중에 스레드 개수를 변경하는 방법 고려
- 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드 고민

### 프로세서 수보다 많은 스레드를 돌려보라
스레드 스와핑(swapping) 때도 문제가 발생할 수 있으므로, 스와핑을 일으키기 위해 더 많은 스레드를 돌림

### 다른 플랫폼에서 돌려보라
코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트 수행

➡️ 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라

### 코드에 보조 코드(instrument)를 돌려라. 강제로 실패를 일으키게 해보라
- Object.wait(), Object.sleep(), Object.yield(), Object.priority() 등과 같은 메서드를 추가해 코드를 다양한 순서로 실행
- 보조 코드를 추가하는 방법은 직접 구현하기와 자동화가 있음

➡️ 흔들기 기법을 사용해 오류를 찾아내라