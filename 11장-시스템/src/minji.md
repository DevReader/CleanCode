# 궁금했던 점
1. Abstract factory 패턴
서로 관련이 있는 객체들을 통째로 묶어서 팩토리 클래스로 만들고, 이들 팩토리를 조건에 따라 생성하도록 다시 팩토리를 만들어서 객체를 생성하는 패턴
2. 영속성
데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성
3. POJO(Plain Old Java Object)
Java로 생성하는 순수한 객체

<br/>

# 정리
## 시스템 제작과 시스템 사용을 분리하라
- 제작(construction)은 사용(use)와 아주 다르다.
- 소프트웨어 시스템은 준비 과정(애플리케이션과 객체를 제작하고 의존성을 서로 **연결** 하는 과정)과 런타임 로직(준비 과정 이후에 이어지는 과정)을 분리 해야한다.
- 시작 단계는 주요 **관심사** 중 하나로, 분리되어야 한다.
- 초기화 지연 기법(Lazy Initialization) 혹은 계산 지연(Lazy Evaluation) 기법은 한 번 정도 사용하는 것은 심각한 문제가 아니지만 수시로 사용하게 되면 저조한 모듈성과 중복 문제를 야기할 수 있다.
- 체계적이고 탄탄한 시스템을 위해서는 모듈성을 깨서는 안된다.
- 객체를 생성하거나 의존성을 연결할 때도 설정 논리는 일반 실행 논리와 분리해야 하고 전반적이고 일관적인 방식을 도입해야 한다.

### Main 분리
시스템 생성과 시스템 사용을 분리하는 한 가지 방법
- 생성과 관련한 코드는 모두 main 이나 main 이 호출하는 모듈로 옮긴다.
- 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.
- main 에서는 시스템에 필요한 객체를 생성하고 애플리케이션에서는 객체가 생성되는 과정을 전혀 모르지만 객체가 적절히 생겼다고 가정하며 객체를 사용한다.

### 팩토리
객체가 생성되는 **시점**을 애플리케이션이 결정해야 할 때 사용하는 방법
- 생성하는 시점을 애플리케이션이 결정하지만 애플리케이션은 객체를 생성하는 코드는 알지 못한다.
- 애플리케이션은 인스턴스가 생성되는 시점을 완벽하게 통제하고 애플리케이션에서만 사용하는 생성자 인수도 넘길 수 있다.

### 의존성 주입
제어 역전(Inversion of Control, IoC) 기법을 의존성 관리에 적용한 메커니즘
- 제어 역전에서 한 객체가 맡은 보조 책임을 새로운 객체에게 떠넘긴다.
- 새로운 객체는 넘겨받은 책임만 맡게 되므로 단일 책임 원칙을 지킨다.
- 호출하는 객체는 실제로 반환되는 객체의 유형을 제어하지 않고 의존성을 능동적으로 해결한다.
- 진정한 의존성 주입은 클래스가 의존성을 해결하게 하지 않고 클래스를 완전히 수동적으로 만든다.
- 의존성을 주입하는 방법으로 설정자(setter) 메서드 또는 생성자 인수(혹은 둘 다)를 제공한다.
- DI 컨테이너는 필요한 객체의 인스턴스를 만든 후 생성자 인수나 설정자 메서드를 사용해 의존성을 결정한다.


## 확장
- 시스템 수준은 수명이 짧다는 본질로 인해 아키텍처의 점진적 발전이 가능하다.
- 비즈니스 논리가 덩치 큰 컨테이너와 밀접하게 결합되어 있으면 독자적인 단위테스트가 어렵다.

### 횡단(cross-cutting) 관심사
흩어진 관심사를 의미한다.
- AOP(Aspect-Oriented Programming) 는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다.
- AOP 따르면 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꾸어야 한다.

## 자바 프록시
- 단순한 상황에 적합하다.
- 프록시의 단점은 코드의 양과 크기가 크다는 것이고, 시스템 단위로 실행 지점을 명시하는 메커니즘을 제공하지 않는다.

## 순수 자바 AOP 프레임워크
- 대부분의 프록시 코드는 비슷해 도구로 자동화가 가능하고 여러 자바 프레임워크에서 내부적으로 프록시를 사용한다. 

## AspectJ 관점
- 관심사를 관점으로 분리하는 가장 강력한 도구이다.
- 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장으로 관점을 분리하는 강력하고 풍부한 도구 집합을 제공하지만 새 언어 문법과 사용법을 익혀야 한다는 단점이 있다.
- AspectJ 애너테이션 폼은 새로운 도구와 새로운 언어라는 부담을 완화한다.
- 스프링은 애너테이션 기반 관점을 쉽게 사용하도록 다양한 기능을 제공한다.

## 테스트 주도 시스템 아키텍처 구축
- 관점으로 관심사를 분리하는 방식은 강력한 방법이고, 코드 수준에서 아케틱처 관심사를 분리할 수 있다면 진정한 테스트 주도 아키텍처 구축이 가능해진다.
- 아주 단순하고 잘 분리된 소프트웨어 프로젝트를 진행해 결과물이 빠르게 나온다면 BDUF(Big Design Up Front)를 추구하지 않기 때문에 기반 구조를 추가하며 조금씩 확장해도 괜찮다.
- 단 프로젝트를 시작할 때는 일반적인 범위, 목표, 일정, 시스템의 일반적인 구조를 생각해야 하고, 변하는 환경에 따라 진로를 변경할 능력을 유지해야 한다.

## 의사 결정을 최적화 하라
- 아주 큰 시스템에서는 한 사람이 모든 결정을 내리기 어렵다.
- 때로는 최대한 정보를 모아 최선의 결정을 내리기 위해 마지막 순간까지 결정을 미루는 방법이 최선일 때가 있다.

## 명백한 가치가 있을 때 표준을 현명하게 사용하라
- 아주 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려나선 안된다.
- 표준을 사용하면 아이디어와 컴포넌트 재사용이 쉬워지고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고 컴포넌트를 엮기 쉽다.
- 때로는 표준을 만드는 시간이 너무 오래걸리거나 표준을 제정한 목적을 잊기도 한다.

## 시스템은 도메인 특화 언어가 필요하다
- DSL(Domain-Specific Language) 은 간단한 스크립트 언어나 표준 언어로 구현한 API를 가리킨다.
- 좋은 DSL 은 도메인 개념과 코드 사이에서 발생하는 간극을 줄여준다.

## 결론
- 시스템 역시 깨끗해야 한다.
- 모든 추상화 단계에서 의도를 명확하게 표현해야 한다. 그를 위해 각 구현 관심사를 분리해야 한다.